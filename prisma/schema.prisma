// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String           @id @default(uuid())
  email        String           @unique
  name         String?
  role         String           @default("candidate") // "candidate" or "recruiter"
  resumes      Resume[]
  applications JobApplication[]
  postedJobs   Job[]            @relation("JobPoster")
  coverLetters CoverLetter[]
  interviews   Interview[]
  createdAt    DateTime         @default(now())
}

model Resume {
  id           String           @id @default(uuid())
  userId       String
  user         User             @relation(fields: [userId], references: [id])
  json         Json?
  vectorId     String? // Qdrant ID returned after upload
  isPrimary    Boolean          @default(false)
  createdAt    DateTime         @default(now())
  applications JobApplication[]
}

model Job {
  id            String   @id @default(uuid())
  title               String
  employerName        String?
  description      String?
  requirements     String?
  location         String?
  salary           String?
  employmentType   String?
  applyLink        String?
  responsibilities String?
  postedBy       String? // User ID of the recruiter who posted this job
  poster         User?   @relation("JobPoster", fields: [postedBy], references: [id])
  createdAt           DateTime @default(now())

  applications JobApplication[]
}

model JobApplication {
  id         String   @id @default(uuid())
  userId     String
  resumeId   String
  jobId      String
  matchScore Int?     // Pre-computed match score (0-100) from job search
  snapshot   Json     // frozen resume copy
  status ApplicationStatus @default(SUBMITTED)
  statusUpdatedAt DateTime? 
  statusUpdatedBy String?       
  notes          Json?           
  withdrawnAt    DateTime? 
  coverLetterId  String?  @unique // Reference to submitted cover letter
  createdAt  DateTime @default(now())

  user   User   @relation(fields: [userId], references: [id])
  resume Resume @relation(fields: [resumeId], references: [id])
  job    Job    @relation(fields: [jobId], references: [id])
  coverLetter CoverLetter?
  interview   Interview?
}

model CoverLetter {
  id                String   @id @default(uuid())
  applicationId    String?  @unique // Link to application (nullable for drafts)
  userId            String   // User who owns this cover letter
  jobId             String   // Job this cover letter is for (for rate limiting)
  
  // Content
  generatedText     String   // AI-generated original text
  finalText         String?  // User-edited final version (null if not edited)
  isEdited          Boolean  @default(false)
  
  // Generation Metadata
  promptVersion     String   @default("v1") // Which prompt variation was used (v1, v2, v3)
  regenerationCount Int      @default(0) // How many times regenerated for this job
  
  // Timestamps
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  // Relations
  user              User     @relation(fields: [userId], references: [id])
  application       JobApplication? @relation(fields: [applicationId], references: [id])
  
  @@index([userId])
  @@index([jobId])
  @@index([applicationId])
}

model Interview {
  id            String          @id @default(uuid())
  applicationId String          @unique
  userId        String          // Candidate user ID
  status        InterviewStatus @default(PENDING)
  transcript    Json?           // Interview transcript stored as JSON
  report        Json?           // Interview report stored as JSON
  reportId      String?         // Reference to interview report (legacy)
  startedAt     DateTime?       // When interview was started
  completedAt   DateTime?       // When interview was completed/failed
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  user        User            @relation(fields: [userId], references: [id])
  application JobApplication  @relation(fields: [applicationId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([applicationId])
  @@index([status])
}

enum ApplicationStatus {
  SUBMITTED
  VIEWED
  SHORTLISTED
  INTERVIEW
  REJECTED
  HIRED
  WITHDRAWN
}

enum InterviewStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
  CANCELLED
}
